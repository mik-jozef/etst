\documentclass[oneside,12pt]{book}

% "Decrements" all counters by one, to fix the society's ignorant exclusion of zero.
% https://tex.stackexchange.com/q/325340/252449
\makeatletter
\def\@arabic#1{\the\numexpr(#1)-1\relax}
\def\@roman#1{\romannumeral\numexpr(#1)-1\relax}
\def\@Roman#1{\expandafter\@slowromancap\romannumeral\numexpr(#1)-1\relax @}
\makeatother

\usepackage[utf8]{inputenc}
\usepackage{titlesec}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{url}
\usepackage[defernumbers]{biblatex}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{mdframed}
\usepackage{xfrac}
\usepackage{thmtools,thm-restate}
\usepackage{multicol}
\usepackage{paralist}
\usepackage{textcomp}
\usepackage[a4paper]{geometry}
\usepackage{tikz}
\usepackage[hidelinks]{hyperref}
\usepackage{csquotes}
\usepackage{scrextend}
\usepackage{listings}

\addbibresource{bib.bib}

\deffootnote[0em]{0em}{1.6em}{\thefootnotemark.\enskip}

\MakeOuterQuote{"}

\counterwithout{footnote}{chapter}

\newmdenv[
  linecolor=lightgray,
  backgroundcolor=lightgray,
  skipabove=7,
  skipbelow=7,
  innertopmargin=7,
  innerbottommargin=7,
  innerleftmargin=7,
  innerrightmargin=7,
  splittopskip=15,
]{defBox}

\definecolor{exampleBoxColor}{RGB}{160, 255, 65}

\newmdenv[
  linecolor=exampleBoxColor,
  backgroundcolor=exampleBoxColor,
  skipabove=7,
  skipbelow=7,
  innertopmargin=7,
  innerbottommargin=7,
  innerleftmargin=7,
  innerrightmargin=7,
  splittopskip=15,
]{exampleBox}

\definecolor{questionBoxColor}{RGB}{175, 130, 200}

\newmdenv[
  linecolor=questionBoxColor,
  backgroundcolor=questionBoxColor,
  skipabove=7,
  skipbelow=7,
  innertopmargin=7,
  innerbottommargin=7,
  innerleftmargin=7,
  innerrightmargin=7,
  splittopskip=15,
]{questionBox}

\newcounter{question}

\makeatletter
\newenvironment{question}{\refstepcounter{question}\par\noindent
  \textbf{\color{black}Open question~\thequestion.} \rmfamily}{}
\newenvironment{conjecture}{\refstepcounter{question}\par\noindent
  \textbf{\color{black}Conjecture~\thequestion.} \rmfamily}{}
\newenvironment{speculation}{\refstepcounter{question}\par\noindent
  \textbf{\color{black}Wild speculation~\thequestion.} \rmfamily}{}
\makeatother

%% We'll define several mathematical sectioning commands.
\theoremstyle{definition}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{lemmaChapter}{Lemma}[chapter]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem*{warning}{Warning}

\theoremstyle{remark}
\newtheorem*{remark}{Remark}

\newenvironment{subproof}[1][\proofname]{%
  \renewcommand{\qedsymbol}{$\blacksquare$}%
  \begin{proof}[#1]%
}{%
  \end{proof}%
}

% https://tex.stackexchange.com/a/9372/252449
\newcommand{\tde}{\raisebox{0.5ex}{\texttildelow}}
\newcommand{\ct}{{\sim}} % complement

\newcommand\var[1]{\mathop{\mathit{#1}}\nolimits}

\newcommand{\pSet}{P}
\newcommand{\mSet}{M}

\newcommand{\approximates}{\sqsubseteq}

\newcommand{\sig}{\var{sig}}
\newcommand{\op}{\var{op}}
\newcommand{\Op}{\var{Op}}

\newcommand{\Var}{\var{Var}}
\newcommand{\SetIII}{\var{Set3}}

\newcommand{\updateValuation}{\var{updateValuation}}
\newcommand{\defeq}{\stackrel{\text{def}}{=}}
\newcommand{\conditional}[3]{#1 \mathrel{?} #2 : #3}

\DeclareMathOperator{\lfp}{lfp}

\newcommand{\approxAll}{*}


\newcommand{\Variable}{\var{Variable}}
\newcommand{\Valuation}{\var{Valuation}}
\newcommand{\Expr}{\var{Expr}}
\newcommand{\DefList}{\var{DefList}}

\newcommand{\dl}{\var{dl}}

\DeclareMathOperator{\mix}{mix}
\DeclareMathOperator*{\limMix}{\lim \mix}
\newcommand{\MBS}{\var{MBS}}


\newcommand{\GPKInf}{\textsc{GPK}^+_\infty}


\newcommand{\false}{\var{tt}}
\newcommand{\true}{\var{ff}}

\newcommand{\Empty}{\mathcal{E}}
\newcommand{\Universal}{\mathcal{U}}

\newcommand{\TruthValues}{\var{TruthValues}}
\newcommand{\Formula}{\var{Formula}}

\newcommand{\PExpr}{\var{PExpr}}

\newcommand{\func}{\var{func}}
\newcommand{\pred}{\var{pred}}
\newcommand{\arity}{\var{arity}}
\newcommand{\symb}{\var{symbol}}

\newcommand\Circle{\raisebox{0.45mm}{\scalebox{0.6}{$\bigcirc$}}}
\newcommand{\meet}{\var{\mathrlap{\Circle}\hspace{3.2pt}\Circle}}

\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\newcommand{\sectionStars}{
\bigskip
*\quad*\quad*
\medskip
}

\title{(Towards a) Boolean Set Theory in a Three-valued Logic}
\author{Jozef Mikušinec}
\date{April 2022, unfinished}

% O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
\begin{document}% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\frenchspacing

\maketitle
\titleformat{\chapter}{}{}{0em}{\bf\LARGE\thechapter~}
\titleformat{name=\chapter,numberless}{}{}{0em}{\bf\LARGE}


\chapter*{Summary}
TODO this summary got outdated pretty fast. Fix when you have a clearer picture
of what this is about. also switch to we instead of I?

This document is a work in progress where I'll try to define the syntax, semantics
and a deductive system for Boolean Set Theory, a set theory in a three-valued
first-order
% recursive\footnote{By recursive logic, I mean that recursive definitions,
% like "A natural number is either zero or a successor of a natural number, where zero
% and successor are ..." are allowed.}
logic, with the empty set and the universal set,
with the universal set closed under union, intersection, powerset, meetset (the set
of all intersecting sets) and complement. The construction is carried out in ZFC.

The work in this document is inspired by my magister thesis~\cite{MikusinecMgrThesis}
and works cited therein. Knowledge of the thesis will [/can?] help with understanding
BST, but is not assumed.

While this document is unfinished, do not trust anything in it -- I'll write
certain things as facts even if I merely suspect that they hold, with the intention
to prove them later, and rewrite those claims if they turn out to be false
(or too hard for me to prove).

In fact, the reader is strictly advised not to waste her time on this pile of half-baked
ideas and unfinished senten

TODO this document is experimental in the sense that if I'm sometimes unsure what
the right approach is, I just guess or take multiple possible approaches.
As a result, some of the concepts explored here might not be as interesting or
fleshed out as others.


\tableofcontents


\chapter{Introduction}
I'd like to do math just like I do code: in a programming language that computers
can verify, and that rests on foundations that I (and, hopefully, other people)
find natural and easy to use.

Unfortunately, it seems to me that current theorem proving languages like Coq or
Idris suffer on the latter front.
Instead, I'd like to have something familiar: types that are understood
as collections of values (ie. sets), and (essentially) classical logic.

At the same time, I'd like to deal with the problem of self-referential negations
in a way that avoids unnecessary restrictions as much as reasonably possible.
The next section explains in detail what I mean.

\section{Negation and self-reference}

Self-reference is a natural part of mathematics.
This is very explicit in programming languages, where it is common to define
functions and data structures in terms of themselves.
However, in math, freely mixing self-references and negations can result
in contradictory definitions, like the Russell's set of sets not containing
themselves, or even more simply, the set of those elements it does not contain.

Traditionally, this issue is dealt with by syntactically restricting what
definitions are considered valid, in a way that guarantees that the valid
definitions cannot be contradictory.%
%
\footnote{In particular, most set theories deal with self-referential negations
by restricting which formulas may be used to specify new sets. For example,
the most widely used set theory, ZFC, only allows one to create subsets
of existing sets when specifying which elements belong to the new set by a logical
formula. Positive set theories, like for instance $\GPKInf$ [TODO cite], allow
comprehension for all positive (roughly meaning "negation-free") formulas.}
%
Under this approach, definitions like the above are simply considered erroneous.
A disadvantage of this approach is that it necessarily also disallows some
definitions that are intuitively meaningful.%
%
\footnote{Whether a particular definition is well-behaved (ie. classical, as defined
later) is Turing-undecidable. Therefore, to disallow all badly behaved definitions,
one must necessarily disallow some well-behaved ones as well.}

Here we attempt a different approach: instead of restricting which definitions
are valid, we give meaning to all of them by  interpreting our sets as three-valued
collections, where every element either defitely belongs to a set, definitely
does not, or its membership in that set is \textit{undetermined}.
Correspondingly, our logic is three-valued as well -- every formula is either true,
false, or undetermined.

Under this approach, "sensible" definitions retain their classical, two-valued
semantics. The additional state \textit{undetermined} is used for
elements whose membership in a set cannot be reasonably determined
because of self-referential negations. Seemingly paradoxical definitions, like
the Russell's set, avoid contradictions using this additional
state; which may also be interpreted as "maybe true or false", or "unknown".

\sectionStars

% TODO Sth like: In this document, we define a set theory with [...] ??

\noindent By moving to a three-valued logic, we depart to an extent from our
initial aspiration of using classical logic. This departure enables placing no
syntactic restrictions on the mathematician when it comes to defining her sets,
and if she is careful, those sets stay classical -- the strange state
\textit{undetermined} may be entirely avoided.
Deciding whether we succeeded in creating a foundation of mathematics that
feels "familiar and natural", we leave to the reader.

% TODO [The decision to [go with/adopt] a three-valued logic/setting has
% unintended, but rich consequences -- only say if you can *really* back that up.]

\section{Outline}
TODO

\subsection{Reading order / dependencies}
TODO sth. like: This diagram shows the dependencies between chapters
[if applicable]. Or: If you are only interested in X, read the zeroth two
chapters, then go to chapter Y and Z.

Eg. The chapters on well-founded collections stray into some issues I find interesting
on their own, however, if you're here just for the set theory, you'll be ok
[with just reading about the least fixed point semantics/with skipping the X and Y]

\section{Related work}
TL;DR: See my magister thesis~\cite{MikusinecMgrThesis}. This document generalizes
and expands on results in the thesis. A lot of material from the thesis is used,
sometimes even directly copied from it, and I feel no shame.

TODO For further references and prior work, see~\cite{MikusinecMgrThesis}.
TODO perhaps copy some of that here, perhaps do some more research to find out
if there is anything else out there that is relevant.

\section{Conventions and notation}

This document uses three kinds of colored boxes to highlight certain its parts.
Definitions are put in a grey box, like the following one.

\medskip \begin{defBox}
  The \textit{universal set} is the set that contains all sets.
\end{defBox}

When introducing new concepts, examples are often useful. If an example
appears in a green box, it is there just to ease understanding and may be
safely skipped or forgotten. Examples introduced outside the green box
may be referred to in latter parts of the document.

\begin{exampleBox}
  TODO an example.
\end{exampleBox}

The last kind of box contains related open problems, stylized as conjectures
or questions. They are chosen subjectively by the author, and might be informal.

\begin{questionBox}
  \textbf{\color{black}Open question X.} Is there a sound and complete deductive
  system for LPC?
  
  \medskip \noindent
  \textbf{\color{black}Conjecture Y.} There are consistent theories of LPC that
  contain [TODO arithmetic/Turing machines and] their own truth predicates.
  TODO will LPC survive the structure overhaul?
\end{questionBox}

This document also includes some warnings:

\begin{warning}
  Research presented in this document has not been published or peer reviewed.
  I do have training in formal mathematics -- I have studied theoretical computing
  science at Masaryk University and got a Magister degree (equivalent to a master's degree). However, one can never be too confident that her thinking is free of error.
  
  Also, sometimes I have doubts whether some of my definitions are natural; when
  that is the case, it will be stated.
  TODO Do I actually do this somewhere? If not, remove this sentence.
\end{warning}

\begin{warning}
  This document is a work in progress.
\end{warning}

By convention, our intervals are closed at the lower bound and open at the upper
bound unless otherwise stated. Our indexing is proper -- it starts at zero.%
\footnote{See "Why numbering should start at zero" by E. W. Dijkstra. Available at
\url{https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html}}

We'll use $a \meet b$ to express that the sets $a$ and $b$ \textit{meet} (have
a common element).

\section{Source and contributing}
TODO create a public repo with this document's source code. Feedback and
contributions are welcome.

But only after this document no longer looks so fucking embarassing.


\chapter{The productive fixpoint / Two-valued collections}
In this secction, we'll introduce [] in a two-valued setting. This will make for
an easy comparison with the three-valued one defined in the next chapter.

\section{Preliminaries: partial algebras}


\chapter{Well-founded collections}
Fix a set $D$, for example the natural numbers, and some (monotonic) operations
on subsets of $D$, for example addition and substraction, defined as follows:
%
\begin{gather*}
  A + B = \{~x \mid x = a + b \text{ for some } a,b \in A,B~\} \\
  A - B = \{~x \mid x = a - b \text{ for some } a,b \in A,B~\}
\end{gather*}

One may then define a system of recursive equations using the above operations
together with binary unions and intersections, and arbitrary unions and
intersections, for example:
%
\begin{align*}
  \var{Even} &= \{~0~\} \cup \var{Even}\,+\,\{~2~\} \\
  \var{Div6} &= \bigcup_{n \in \var{Even}}n + n + n
\end{align*}

These equations can be viewed as defining the values of the variables to be the
equations' least fixed point.\footnote{Assuming the equations are viewed as
the corresponding (monotonic) function on $\pSet(D)^2$.}

Well-founded collections (WFC) are a generalization of the standard least fixpoint
semantics that in addition to the mentioned operations is capable of handling
set complements, including those that are contradictory in a classical,
two-valued sense.%
%
\footnote{Well-founded collections are also a generalization of WFRQ, the subject
of my magister thesis~\cite{MikusinecMgrThesis}, the difference being that WFRQ
uses records (aka. structs or objects) as $D$, while WFC is generalized to allow
any set $D$ with any monotonic operations.}
%
\begin{align*}
  \var{Nat} &= \ct\{\} \\
  \var{Even} &= \var{Nat}\,\cap~\ct(\var{Even}\,+\,\{~1~\}) \\
  \var{Undetermined} &= \ct\var{Undetermined}
\end{align*}

In this and the following chapter, we will formally define well-founded collections.

\section{Three-valued collections}
A recurring theme in this document is that of a three-valued collection.
Every element either definitely belongs, or does not belong to a two-valued collection.
A three-valued collection offers one extra possibility -- an element's membership in the
collection may be undetermined.

An element that definitely belongs to a collection C is said to be a \textit{definite
member} (or just a \textit{member}) of C. An element that definitely does not is
said to be a (definite) \textit{nonmember} of C. An element whose membership in C
is undetermined is said to \textit{border} C.

(Definite) members and undetermined elements are called the \textit{possible members}.
Similarly, nonmembers and undetermined elements are called the \textit{possible
nonmembers}.

A three-valued collection is \textit{classical} (or \textit{fully determined}) iff
its membership relation is determined for every element, or in other words,
iff all its possible members are its definite members.

\section{Formalizing three-valued collections}
Two-valued collections of elements of some set $S$ are just the subsets of $S$.
Three-valued collections can be formalized in two equivalent ways:

\begin{defBox}
  \begin{description}
    \item[Definition 0] \hfill \\
      A 3-valued collection of elements of $S$ is a pair $(L, U)$, where
      $L \subseteq U \subseteq S$.
    \item[Definition 1] \hfill \\
      A 3-valued collection of elements of $S$ is a function from $S$
      to $\{ 0, \bot, 1 \}$.
  \end{description}
\end{defBox}

asdf TODO say that the definition 1 will be called the characteristic function
of trisets

\noindent These two definitions are equivalent, because every element of $S$ can either
\begin{compactenum}
  \item be a member of both $L$ and $U$ (be a definite member),
  \item be a member of $U$, but not $L$ (border the collection),
  \item be a member of neither $U$ nor $L$ (be a definite nonmember).
\end{compactenum}

\medskip \noindent The third option -- that an element of $S$ is a member of $L$,
but not $U$ -- is probihited by the requirement that $L$ is a subset of $U$.
The sets $L$ and $U$ can be thought of as forming a lower and upper bound on
the membership of elements of $D$ in the three-valued collection.

The latter definition better illustrates the three-valuedness, but by default,
we’ll keep using the former. To avoid confusion with two-valued sets, we will
call the three-valued sets "trisets".

\begin{defBox}
  $\SetIII(D)$ is the set of all trisets of elements of $D$.
\end{defBox}

\begin{exampleBox}
  Here are some examples of trisets of natural numbers:
  
  \medskip \noindent $(\emptyset, \emptyset)$ contains no numbers, and
  $(\mathbb{N}, \mathbb{N})$ contains all of them. Neither of these trisets
  borders any element.
  
  \medskip \noindent $(\emptyset, \mathbb{N})$ definitely contains no numbers,
  but possibly contains all of them. Similarly, no number is its definite nonmember,
  but every number is its possible nonmember. It borders every number.
  
  \medskip \noindent $(\{ 0, 1 \}, \{ 0, 1, 2 \})$ definitely (and possibly)
  contains numbers 0 and 1, but only possibly contains the number 2. Therefore
  it borders the number 2.
\end{exampleBox}

\section{Orderings on trisets}
We'll define two orderings on three-valued sets: the standard ordering,
and the approximation ordering. These will be later used to show that our
construction of the semantics of WFC converges to a fixed point.

A triset $A$ is smaller than $B$ in the standard ordering if it contains fewer elements
(both definite and possible), and is smaller in the approximation ordering
if it agrees with $B$ on the membership of $B$'s determined elements (but may
have fewer of them than $B$).

A triset becomes larger in the standard ordering iff some elements are added to it,
while it becomes larger in the approximation ordering if some of its undetermined
elements become determined.

\begin{defBox}
  In the standard ordering, $(L_0, U_0) \leq (L_1, U_1)$ iff $L_0 \subseteq L_1$
  and $U_0 \subseteq U_1$.
  
  \medskip \noindent
  In the approximation ordering, $(L_0, U_0) \approximates (L_1, U_1)$
  iff $L_0 \subseteq L_1$ and $U_1 \subseteq U_0$.
\end{defBox}

\begin{proposition}[Least trisets] \label{leastTrisets} \hfill \\
  The least triset with respect to the standard (resp. approximation) ordering
  is the empty triset $(\emptyset, \emptyset)$ (resp. the wholly undetermined
  triset $(\emptyset, D)$).
\end{proposition}

\begin{proposition}[Least upper bounds of triset chains]
\label{leastUpperBoundsTrisets} \hfill \\
  Let $T \subseteq \SetIII(D)$ be any chain with respect to the standard
  (resp. approximation) ordering. Then its least upper bound equals
  \[(\bigcup_{(l,u) \in T}l,\bigcup_{(l,u) \in T}u)\,,
  \text{ resp. } (\bigcup_{(l,u) \in T}l,\bigcap_{(l,u) \in T}u)\].
\end{proposition}

\begin{corollary}
  The orderings on triset chains are chain-complete (that is, every chain has
  a least upper bound).
\end{corollary}


\section{Syntax of WFC}
\subsection{Signatures}
% TODO perhaps name it something else? I don't like that a signature
% specifies not just the arity of operations, but also their implementation
% On the other hand, there is no concept of models...
% Also, this is under the section "Syntax of WFC" and I'm like "an interpretation
% is ..." wtf?
A signature specifies the particular set $D$ and the operations on it.
Well-founded collections are defined relatively to a signature. Unlike in
logic, a signature for WFC also specifies the interpretation of the operations.

\begin{defBox}
  A signature is a 4-tuple $(D, A, \Op, I)$, where
  \begin{compactitem}
    \item $D$ is an arbitrary set,
    \item $A$ a subset of $D$ is a set of approximative values (explained later),
    \item $\Op$ is a set of operations (just an arbitrary set)
    \item $I$ -- the interpretation
      of operations on D -- is a function such that for each $\op \in \Op$,
      $I(\op)\colon \pSet(D)^n \to \pSet(D)$ is monotonic ($n$ being the arity
      of $\op$).
  \end{compactitem}
\end{defBox}

\subsection{Expressions}
The syntax of WFC may be denoted using two possible notations -- math
(eg. $A \cup B$) or code notation (eg. \texttt{A | B}) -- we'll use both
interchangeably.

An expression of WFC is defined recursively as follows:

\noindent
\begin{minipage}{\linewidth}
\noindent
\begin{multicols*}{3}
  \noindent
  \begin{align*}
    E =&~x \\
     |&~f(...) \\
     |&~E \cup E \\
     |&~E \cap E \\
     |&~\ct E \\
     |&~\bigcup_{x \in E}E \\
     |&~\bigcap_{x \in E}E
  \end{align*}
  \begin{align*}
      \texttt{E =}&\texttt{ x} \\
      \texttt{|}&\texttt{ f(...)} \\
      \texttt{|}&\texttt{ E | E} \\
      \texttt{|}&\texttt{ E \& E} \\
      \texttt{|}&\texttt{ \tde E} \\
      \texttt{|}&\texttt{ Un x: E .. E} \phantom{\bigcup_E} \\
      \texttt{|}&\texttt{ Ir x: E .. E} \phantom{\bigcup_E}
  \end{align*}
  \begin{align*}
    &\text{Variables} \\
    &\text{Custom operations} \\
    &\text{Binary union} \\
    &\text{Binary intersection} \\
    &\text{Complement} \\
    &\text{Arbitrary union} \phantom{\bigcup_E} \\
    &\text{Arbitrary intersection} \phantom{\bigcup_E}
  \end{align*}
\end{multicols*}
\end{minipage}

\medskip \noindent
The arity of the custom operations is determined by the particular signature used.

\begin{defBox}
  $\Variable = \mathbb{N}$ is the set of all variables.

  \medskip \noindent
  Let $\sig$ be a signature, $\Var$ a set of variables, and $n$ a natural number.
  
  \medskip \noindent
  $\Expr_{\sig,\Var,n}$ is the set of all expressions of depth at most $n$ whose
  free variables belong to $\Var$.

  \medskip \noindent $\Expr_{\sig,\Var}$ is the set of all expressions whose
  free variables belong to $\Var$.
  
  \medskip \noindent $\Expr_{\sig} = \Expr_{\sig,\Variable}$ is the set of all
  expressions.
\end{defBox}

\subsection{Defition lists}

A definition is a named expression. Definitions are grouped into definition
lists. A definition list allows its definitions to refer to each other.

In math notation, definition lists will be denoted as shown at the start of the
chapter (where we called a definition list a "system of recursive equations").
In code notation, definitions will be preceded with the keyword "let":
\begin{align*}
  &\texttt{let Even = \{ 0 \} | Even + \{ 2 \};} \\
  &\texttt{let Div6 = Un n: Even .. n + n + n;}
\end{align*}

\begin{defBox}
  Let $\sig$ be a signature and $\Var$ a set of variables.
  
  \medskip \noindent
  A family of expressions is a function $f\colon \Var \to \Expr_{\sig,\Var}$.
  
  \medskip \noindent A family of expressions is a \textit{definition list} iff it is
  the union of (possibly infinitely many) finite families of expressions.

  % TODO Should I also define DefList_sig,Var,n?
  \medskip \noindent $\DefList_{\sig,\Var}$ is the set of all definition lists
  whose domain is $\Var$.
  
  \nopagebreak \medskip \noindent $\DefList_{\sig} = \DefList_{\sig,\Variable}$
  is the set of all definition lists.
\end{defBox}

We require definition lists to be unions of finite families of expressions
to dissalow "definition lists" whose definitions run on forever, like these:
\begin{gather*}
  \texttt{let Def0 = Def1;} \\
  \texttt{let Def1 = Def2;} \\
  \texttt{let Def2 = Def3;} \\
  \texttt{...}
\end{gather*}


\chapter{Semantics of WFC}
\section{Valuations}

A valuation is an assignment of trisets to variables. Valuations
let us interpret expressions as representing a concrete triset.

\begin{defBox}
  A valuation is a function $v\colon \Var \to \SetIII(D)$ for some
  $\Var \subseteq \Variable$.
  
  \medskip \noindent $\Valuation_{\Var,D}$ is the set of all valuations
  from $\Var$ to $\SetIII(D)$
  
  \medskip \noindent Where the domain can be assumed from context,
  $v_e = x \mapsto (\emptyset, \emptyset)$ is the empty valuation,
  and $v_u = x \mapsto (\emptyset, D)$ is the undetermined valuation.
\end{defBox}

The standard and approximation orderings can be extended to valuations as well.

\begin{defBox}
  For either ordering, valuations are ordered pointwise.
  
  \medskip \noindent That is, a valuation $v_0\colon \Valuation_{\Var,D}$
  is less than $v_1\colon \Valuation_{\Var,D}$ iff for every $x \in \Var$,
  $v_0(x)$ is less than $v_1(x)$.
\end{defBox}

\begin{proposition}[Least valuations]\label{leastVal} \hfill \\
  The least element of the standard ordering is
  $x \mapsto (\emptyset, \emptyset)$, and the least element of the approximation
  ordering is $x \mapsto (\emptyset, D)$.
\end{proposition}

\begin{proposition}[Least upper bounds of valuation chains]
\label{leastUpperBoundsValuations} \hfill \\
  Let $T$ be any chain of valuations with respect to the standard
  (resp. approximation) ordering. Then its least upper bound exists, and its value
  at $x$ equals the least upper bound of the values of valuations in $T$ at $x$.
\end{proposition}

\begin{corollary}\label{valChainComplete}
  The orderings on valuations are chain-complete.
\end{corollary}

\section{An informal overview}
Our goal in this chapter is to, given a particular definition list $\dl$, associate
a three-valued set to each definition of $\dl$. More precisely, we need to
find a valuation that assigns to every definition of $\dl$ a triset that "agrees"
with the expression that forms that definition.

Our obstacle is that definitions are typically circular. The solution is to build
the valuation incrementally, in stages.
Here we give an informal overview of the formal machinery of this chapter.
It is in principle based on the one used in~\cite{WfSemBoolGrammar}.

\subsection{The standard solution}
When dealing with circular definitions, the usual solution would
be the following:

Zeroth, we would define an interpretation function that takes
a valuation and an expression, and returns the value of that expression
when the value of its free variables is determined by the valuation.

Starting with the empty valuation $v_e$, we would then iteratively build new valuations
using the interpretation of the definitions of $\dl$ under the valuation from
the previous step\footnote{Perhaps transfinitely many times.}:
\begin{gather*}
  \texttt{\small let Nat = \{ 0 \} | Nat + \{ 1 \};} \\
  \{\} \rightarrow \{ 0 \} \rightarrow \{ 0, 1 \} \rightarrow \{ 0, 1, 2 \}
    \rightarrow ... \rightarrow \mathbb{N}
\end{gather*}
Formally, we would define an operator $O_{\dl}$ on valuations that takes the $n$th
such valuation to the $n+1$th one, and define the semantics of $\dl$ as $O_{\dl}$'s
least fixed point -- the least valuation $v$ such that $v = O_{\dl}(v)$.
\[v = O_{\dl}(v) = O_{\dl}(O_{\dl}(v)) = ...O_{\dl}(O_{\dl}(O_{\dl}(v_e)))...\]

\subsection{The issue}
The least fixed point may not always exist for an arbitrary operator. One way
to ensure its existence is by exhibiting a certain\footnote{Not any
ordering will do. We need the supremums of directed subsets to exist.} ordering
with respect to which the operator is monotonic.
Intuitively, one may view such an ordering as preventing cycling between distinct
valuations.\footnote{Infinite ascending chains are not a problem, since in that case,
we just take their supremum and continue the process. This is why we need
transfinite stages, and the supremums to exist.}

The standard approach works for definitions not containing complements
or arbitrary intersections, because all the other operations are monotonic
with respect to the standard ordering (where a triset is larger iff it contains
more elements).

However, it has a serious flaw: complement and the arbitrary
intersection are not monotonic. The problem is not just with the choice
of the ordering -- definitions using them can fail to have a (least) fixpoint.
\begin{gather*}
  \texttt{\small let Bad = \tde Bad;} \\
  \{\} \rightarrow \mathbb{N} \rightarrow \{\} \rightarrow \mathbb{N}
    \rightarrow ... \rightsquigarrow~\!!
\end{gather*}


\subsection{Our solution}
To fix this flaw, we'll introduce another valuation, called "background"
(we'll call the original valuation "context"). The interpretation gets both
valuations as parameters, and is modified to use the background valuation when
interpreting complements and arbitrary intersections (and their subexpressions),
and uses the context for everything else.

Starting with the undetermined valuation as the background and the empty valuation
as context, our iterative construction now proceeds in two dimensions:
\begin{gather*}
  b_0, c_{0,0} \rightarrow b_0, c_{0,1} \rightarrow b_0, c_{0,2}
    \rightarrow ... \rightarrow b_0, b_1 \\
  \downarrow \\
  b_1, c_{1,0} \rightarrow b_1, c_{1,1} \rightarrow b_1, c_{1,2}
    \rightarrow ... \rightarrow b_1, b_2 \\
  \vdots \\
  b_n, c_{n,0} \rightarrow b_n, c_{n,1} \rightarrow b_n, c_{n,2}
    \rightarrow ... \rightarrow b_n, b_n
\end{gather*}

In the inner (horizontal) sequences, context is updated as before,
while the background stays constant. Because the background is constant,
the interpretation of complements is constant as well, so the horizontal
sequences are monotonic with respect to the standard ordering.
When a fixed context is reached, it is used as the next background in the next
step of the outer (vertical) sequence.

Just like the standard iterative construction, the above two-dimensional one
can also be expressed in terms of an operator. (More precisely, one outer
operator, and one family of inner operators, one for each possible background.)
To prove the existence of the least fixed point of the outer operator, we'll show
it is monotonic with respect to the approximation ordering (where a triset
becomes larger iff some of its undetermined elements become determined).
The fixed point will serve as the definition of the semantics of WFC.

\sectionStars

\noindent Besides defining the operators themselves, we'll also define the results
of the iterative construction of the fixpoint at ordinal stages. That is, for
an operator $f\colon T \to T$, we'll also define $f_{n\colon Ord}\colon T$
in terms of its previous stages, where $f_n$ equals the result of applying
the operator $f$ $n$ times.

Such a construction is also formally valid on its own (by the transfinite recursion
theorem~\cite{Rin2014TransfiniteRA}), and is more practical, too. We'll,
however, define the operators as well, to show that the iterative construction
agrees with the least fixed point of a naturally defined operator.
Equivalence between these two approaches is proven.

\subsection{An algorithmic view}

If one is willing to entertain the idea of an algorithm that terminates
after a (potentially) transfinite number of steps, she can view a single application
of the operator $O_{\dl}$ as corresponding to a single iteration of the loop below
on the left, and finding $O$'s least fixpoint as executing that loop.
Similarly, the (outer and inner) operators can be viewed as the nested loops on the right.
%
\begin{center}
\begin{tabular}{c|c}
\begin{lstlisting}[basicstyle=\footnotesize]
v = the empty valuation;

while (v has changed) {
  v = (x) => I(v)(dl(x));
}
\end{lstlisting} &
\begin{lstlisting}[basicstyle=\footnotesize]
b = the undetermined valuation;
c = the empty valuation;

while (b has changed) {
  while (c has changed) {
    c = (x) => I(b, c)(dl(x));
  }
  
  b = c;
  c = the empty valuation;
}
\end{lstlisting}
\end{tabular}
\end{center}

\subsection{Value approximation}
Imagine the following definition: \[\texttt{let P = (P, P);}\] If we are working
in a setting where self-containing pairs like $p = (p, p)$ are allowed
(ie. if our signature's $D$ contains such values), we would naturally expect
$P$ to specify a triset containing exactly the pair $p$. However,
without value approximation, the least fixed point of the definition would be
the empty triset.

It is for this reason that signatures contain the set $A$ of approximative
values. The pair $p$ is approximated by values like $*$, $(*, *), (*, (*, *))$
and so on. To cover values like $p$, during the iterative construction we add values
to a triset if their arbitrarily precise approximations are already in that triset.
As the last step, we remove the approximative values from our trisets so they are
not part of the meaning of definitions.

\begin{warning}
  I am not sure whether approximative values are the best approach to dealing
  with self-containing values. I am also not sure whether there aren't any
  corner cases where this approach brings unintuitive results, even in cases
  they are fine-tuned to be "right". Consider them an experimental feature.
  
  Alternative approaches that I considered were: greatest fixed points (unsuitable
  for non-self-containing values, only productive definitions should have
  greatest-fixpoint semantics, eg. \texttt{let T = T;} should be empty), letting
  the mathematician choose per definition whether it should be a least- or greatest
  fixpoint inducing (what if such definitions use each other?), final coalgebras
  (no idea how that would even work).
  
  Update: I think I will make WFC work atop partial algebras. Then I should be (more
  likely to be) able to do this approximation thing general and proper.
\end{warning}


\section{Interpretation of expressions}
Interpretation is a function that takes two valuations and an expression, and
returns a three-valued set represented by that expression. We'll define it
recursively on the structure of the expression. The valuations $b$ and $c$ stand
for "background" and "context".

\begin{defBox}
  Let $\sig = (D, A, \Op, I_s)$ be a signature, and $\Var$ a set of variables..
  
  \bigskip \noindent
  $I_{\sig}\colon (b, c \colon \Valuation_{\Var,D}) \to \Expr_{\sig,\Var} \to \SetIII(D)$
\end{defBox}

The interpretation of variables is given by the context valuation,
and the interpretation of custom operations by the signature's interpretation
function $I_s$.

\begin{defBox}
  $I_{\sig}(b,c)(\texttt{var}) = c(\texttt{var})$
  
  \medskip \noindent $\begin{aligned}
    I_{\sig}(b,c)(\texttt{f([e0], ..., [eN])}) =
      (&I_s(\texttt{f})
        (I_{\sig}(b,c)(\texttt{e0})[0], ..., I_{\sig}(b,c)(\texttt{eN})[0]), \\
      &I_s(\texttt{f})
        (I_{\sig}(b,c)(\texttt{e0})[1], ..., I_{\sig}(b,c)(\texttt{eN})[1]))
    \end{aligned}$
\end{defBox}

The definite (resp. possible) members of triset union are the union
of the definite (resp. possible) members of the arguments. Same for intersection.

\begin{defBox}
  $\begin{aligned}
    I_{\sig}(b,c)(\texttt{[e0] | [e1]}) =
    (&I_{\sig}(b,c)(\texttt{e0})[0] \cup I_{\sig}(b,c)(\texttt{e1})[0], \\
    &I_{\sig}(b,c)(\texttt{e0})[1] \cup I_{\sig}(b,c)(\texttt{e1})[1])
    \end{aligned}$
  
  \bigskip \noindent $\begin{aligned}
    I_{\sig}(b,c)(\texttt{[e0] \& [e1]}) =
    (&I_{\sig}(b,c)(\texttt{e0})[0] \cap I_{\sig}(b,c)(\texttt{e1})[0], \\
    &I_{\sig}(b,c)(\texttt{e0})[1] \cap I_{\sig}(b,c)(\texttt{e1})[1])
    \end{aligned}$
\end{defBox}

The triset complement swaps definite members for definite nonmembers,
and vice versa. Undetermined elements stay undetermined. Notice that
the complement is defined only in terms of the background valuation.

\begin{defBox}
  $\begin{aligned}
    I_{\sig}(b,c)(\texttt{\tde [e]}) =
    (&D \setminus I_{\sig}(b,b)(\texttt{e})[1], \\
    &D \setminus I_{\sig}(b,b)(\texttt{e})[0])
    \end{aligned}$
\end{defBox}

To define the interpretation of arbitrary unions and intersections, we zeroth
need a supporting definition:

The function $\updateValuation$  accepts a valuation, a variable $x$ and an element
$e$ of $D$, and returns a valuation that under the variable $x$ contains the triset
containing just $e$, and leaves other variables unchanged.

\begin{defBox}
  $\updateValuation\colon
    \Valuation_{\Var,D} \times (x\colon \Variable) \times D
      \to \Valuation_{\Var \cup\,\{x\},D}$
  
  \medskip \noindent
  $\updateValuation(v, x, r)) \defeq v[x \mapsto r] = x_n \mapsto \begin{cases}
  (\{r\},\{r\}) & x_n = x\\
  f(x_n) & \text{else}
  \end{cases}$
\end{defBox}

Note that in the case of arbitrary intersection, the domain is defined only
in terms of the background, like in the case of complement.

\begin{defBox}
  $I_{\sig}(b,c)(\texttt{Un x: [e0] .. [e1]}) = \\
    \phantom{aaa} \begin{aligned}
    (&\bigcup_{r \in I_{\sig}(b,c)(\texttt{e0})[0]}
    I_{\sig}(b[x {\mapsto} r], c[x {\mapsto} r])(\texttt{e1})[0],\\
    &\bigcup_{r \in I_{\sig}(b,c)(\texttt{e0})[1]}
    I_{\sig}(b[x {\mapsto} r], c[x {\mapsto} r])(\texttt{e1})[1])
    \end{aligned}$
  
  \bigskip \noindent $I_{\sig}(b,c)(\texttt{Ir x: [e0] .. [e1]}) = \\
    \phantom{aaa} \begin{aligned}
    (&\bigcap_{r \in I_{\sig}(b,b)(\texttt{e0})[1]}
    I_{\sig}(b[x {\mapsto} r], c[x {\mapsto} r])(\texttt{e1})[0],\\
    &\bigcap_{r \in I_{\sig}(b,b)(\texttt{e0})[0]}
    I_{\sig}(b[x {\mapsto} r], c[x {\mapsto} r])(\texttt{e1})[1])
    \end{aligned}$
  
  \bigskip \noindent When the background is not provided, it is assumed to
  equal the context, that is, $I_{\sig}(c)$ is defined as $I_{\sig}(c, c)$.
\end{defBox}

\begin{proposition}[Interpretation is a triset] \hfill \\
  The interpretation of any expression $e$ under any valuations $b$, $c$
  is a triset $(L, U)$, that is, $L \subseteq U$.
\end{proposition}

\begin{lemma}[Standard monotonicity of interpretation]\label{monoInterpStd} \hfill \\
  For any valuation $b\colon \Valuation_{\Var,D}$ and expression
  $e \in \Expr_{\sig,\Var}$, the function $c \mapsto I_{\sig}(b, c)(e)$
  is monotonic with respect to the standard ordering.
  
  (Informally, if the context gets more elements, the interpretation
  gets more elements.)
\end{lemma}
\begin{proof}
  By induction over the structure of the expression, and an extensive number
  of cases. We'll explicitly prove only the inductive step for the quantifiers,
  the rest is trivial. (The complement is particularly easy,
  since it is constant with respect to $c$.)
  
  Let $c_0$ and $c_1$ be valuations such that $c_0 \leq c_1$. Then for any
  $x$ and $r$, \[c_0[x {\mapsto} r] \leq c_1[x {\mapsto} r]\,.\]
  
  Let $e = \displaystyle\bigcup_{x \in e_0}e_1 \in \Expr_{\sig,\Var}$.
  Then $e_0 \in \Expr_{\sig,\Var}$ and $e_1 \in \Expr_{\sig,\Var\cup\{x\}}$.
  
  By the induction hypothesis, we have that
  \begin{align*}
    I_{\sig}(b', c_0')(e_0) \leq I_{\sig}(b', c_1')(e_0) \\
    I_{\sig}(b', c_0')(e_1) \leq I_{\sig}(b', c_1')(e_1)
  \end{align*}
  for any $c_0'$, $c_1'$ and $b'$ such that $c_0' \leq c_1'$, and therefore also
  for $b' = b[x {\mapsto} r]$, $c_0' = c_0[x {\mapsto} r]$
  and $c_1' = c_1[x {\mapsto} r]$, for any $r \in D$.
  
  To recap:
  \begin{gather*}
    s_0 = I_{\sig}(b, c_0)(e_0) \leq s_1 = I_{\sig}(b, c_1)(e_0) \\
    t_0 = I_{\sig}(b[x {\mapsto} r], c_0[x {\mapsto} r])(e_1)
      \leq t_1 =  I_{\sig}(b[x {\mapsto} r], c_1[x {\mapsto} r])(e_1)\,.
  \end{gather*}
  
  By the definition of the standard ordering, $s_0[j] \subseteq s_1[j]$
  and $t_0[j] \subseteq t_1[j]$. By the definition of $I$,
  \[I_{\sig}(b, c_i)(e)[j] = \bigcup_{r \in s_i[j]}t_i[j]\,.\]
  
  Finally, \[\bigcup_{r \in s_0[j]}t_0[j] \subseteq \bigcup_{r \in s_1[j]}t_1[j]\,.\]
  therefore \[I_{\sig}(b, c_0)(e) \leq I_{\sig}(b, c_1)(e)\,.\]
  
  \noindent % Saving space so that the proof of the lemma below is on the same page.
  The case of the universal quantifier is a little simpler: the index set of the
  intersections in its definition is constant with respect to $c$, and the
  "body" of the intersections is proven monotonic as above, so the whole
  expression is monotonic.
\end{proof}

\begin{lemma}[Approximation monotonicity of interpretation]
\label{monoInterpKnow} \hfill \\
  Let $e \in \Expr_{\sig,\Var}$ be an expression, and 
  $b_0, b_1, c_0, c_1\colon \Valuation_{\Var,D}$ valuations such that
  $b_0 \approximates b_1$ and $c_0 \approximates c_1$.
  Then $I(b_0, c_0)(e) \approximates I(b_1, c_1)(e)$.
  
  (Informally, if the either background or context become more determined,
  the interpretation becomes more determined.)
\end{lemma}
\begin{proof}
  Similar in principle to the proof of standard monotonicity.
\end{proof}

We can extend the interpretation of expressions to entire definition lists,
pointwise.

\begin{defBox}
  $I_{\sig}\colon (b,c\colon \Valuation_{\Var,D}) \to \DefList_{\sig,\Var}
    \to \Valuation_{\Var,D}$
  
  \medskip \noindent
  $I_{\sig}(b, c)(\dl) = x \mapsto I_{\sig}(b, c)(\dl(x))$
\end{defBox}

This extended interpretation is monotonic with respect to the standard and
approximation orderings in the same way as the interpretation of expressions.

\begin{defBox}
  A valuation $v$ is \textit{stable} with respect to a definition list $\dl$,
  or a \textit{model} of $\dl$, iff $I(v)(\dl) = \dl$.
\end{defBox}

% TODO perhaps call it [Interpretation and] Mixing?
\subsection{A theorem about the interpretation}
This theorem illustrates a nice property of the interpretation, although it
isn't used later.

\begin{defBox}
  A (proper) classical completion of a triset $s$ is a classical triset
  (strictly) greater than $s$ in the approximation ordering.
  
  % TODO
  
  \medskip \noindent Given a nonempty set of trisets $S$, the \textit{mix} of $S$
  is the triset such that:
  \begin{compactitem}
    \item a value belongs to $\mix(S)$ iff it belongs to every element of $S$,
    \item a value doesn't belong to $\mix(S)$ iff it belongs to no element of $S$
    \item a value borders $\mix(S)$ otherwise.
  \end{compactitem}
\end{defBox}

\begin{proposition}
  The mix of $S$ is the greatest triset less than any element of $S$ in the
  approximation ordering.
\end{proposition}

\begin{theorem} [Interpretation commutes with mixing] \hfill \\
  The interpretation of any expression $e$ under any valuation $v$ is the mix
  of the interpretations of $e$ under the classical completions of $v$.
  In symbols: \[I_{\sig}(v)(e) = \mix_{v' \in V}(I_{\sig}(v')(e))\,,\]
  where $V$ is the set of classical completions of $v$.
  % I sense commutative diagrams. Mixing the classical completions and then
  % doing the interpretation equals doing the interpretations and then mixing.
  % Category theory, I really should give you a serious try.
  
\end{theorem}

\begin{proof}
  TODO proof.
\end{proof}

\subsection{The conditional operator}
In practice, a conditional operator often makes for convenient definitions.
Luckily for us, an operator \texttt{C ? A : B} that would take a triset $C$
and return the triset $A$ when $C$ is nonempty, else would return the triset $B$,
is expressible using the other operations as follows:
\[\texttt{(Ex \_: C .. B) | (Ex \_: \tde C .. B)}\,.\]

\section{The operators and the iterative construction}
Now we'll define a family of operators $C_{b}$ that, given a background $b$,
accept a context valuation and return the next context, and the operator $B$ that
accepts a background valuation and returns the next background,

\begin{defBox}
  Let $\dl\colon \DefList_{\sig,\Var}$ a definition list, and
  $b\colon \Valuation_{\Var,D}$ a valuation.
  
  \medskip \noindent $C_{\sig,\dl,b}
    \colon \Valuation_{\Var,D} \to \Valuation_{\Var,D}$
  
  \nopagebreak \smallskip \noindent $C_{\sig,\dl,b}(c) = I_{\sig}(b,c)$
  
  \bigskip \noindent $B_{\sig,\dl}
    \colon \Valuation_{\Var,D} \to \Valuation_{\Var,D}$
  
  \nopagebreak \smallskip \noindent $B_{\sig,\dl}(b) = \lfp(C_{\sig,\dl,b})$
\end{defBox}

...together with the corresponding iterative constructions.

\begin{defBox}
  Let $n$ be any ordinal, and $l$ be any limit ordinal.
  
  \medskip \noindent $C_{\sig,\dl,b,n}\colon \Valuation_{\Var,D}$
  
  \nopagebreak \medskip \noindent
  $\begin{aligned}
    & C_{\sig,\dl,b,0} & &= v_e \\*
    & C_{\sig,\dl,b,n+1} & &= I_{\sig}(b, C_{\sig,\dl,b,n}) \\*
    & C_{\sig,\dl,b,l} & &= x \mapsto (\bigcup_{i \in l}C_{\sig,\dl,b,i}(x)[0],
      \ \bigcup_{i \in l}C_{\sig,\dl,b,i}(x)[1])
  \end{aligned}$
  
  \medskip \noindent $B_{\sig,\dl,n}\colon \Valuation_{\Var,D}$
  
  \nopagebreak \medskip \noindent
  $\begin{aligned}
    & B_{\sig,\dl,0} & &= v_u \\*
    & B_{\sig,\dl,n+1} & &= C_{\sig,\dl,b,|2^D|} \text{, where } b = B_{\sig,\dl,n} \\*
    & B_{\sig,\dl,l} & &= x \mapsto (\bigcup_{i \in l}B_{\sig,\dl,i}(x)[0],
      \ \bigcap_{i \in l}B_{\sig,\dl,i}(x)[1])
  \end{aligned}$
  
  \footnotetext{Recall that $v_e$ and $v_u$ are the empty and the undetermined
  valuation, respectively.}
\end{defBox}

The rest of the section is filled with proofs of the equivalence of these,
which the reader so inclined may freely skip.

\begin{proposition}
  The operator $C_{\sig,\dl,b}$ is monotonic with respect to the standard ordering,
\end{proposition}

\begin{restatable}[Well-ordered chains of valuations are small]%
{lemma}{wellOrderedChainsSmall} \label{wellOrderedChainsSmall} \hfill \\
  Let $\Var$ be a \textit{finite} set of variables, and
  $V \subseteq \Valuation_{\Var,D}$ a well-ordered chain of valuations with
  respect to either ordering. Then the cardinality of $V$ equals that of $D$
  up to a finite difference.
\end{restatable}

\begin{proof}
  A proof is in the appendix~\ref{proofCoConst}.
\end{proof}

\begin{restatable}[Correctness of the construction of least fixed points]%
{lemma}{lemmaCoConst} \label{coConst} \hfill \\
  Let $T$ be a set with a chain-complete partial order $\leq$ such that
  all well-founded chains of $T$ have a cardinality at most $k$,
  and $O\colon T \to T$ a monotonic operator on $T$.
  
  Let $O_{n\colon Ord}\colon T$ be an element of $T$ defined like this:
  \begin{align*}
      O_0 & = \text{ the least element of }T \\
      O_{n+1} & = O(O_n) \\
      O_l & = \text{ the least upper bound of }O_{n<l}
  \end{align*}
  %
  Then $O_{|2^k|}$ is the least fixed point of $O$.
\end{restatable}

\begin{proof}
  A proof of this theorem is in the appendix~\ref{proofCoConst}.
  It is a variation the Bourbaki--Witt theorem and other similar theorems.
\end{proof}

\begin{lemma}[Correctness of construction of $C_b$'s least fixed point]
\label{coConstOpC} \hfill \\
  Let
  \begin{compactitem}
    \item $\sig = (D, A, \Op, I)$ be a signature,
    \item $\Var$ a set of variables,
    \item $b$ a $\Valuation_{\Var,D}$, and
    \item $\dl$ a $\DefList_{\sig,\Var}$.
  \end{compactitem}
  
  \medskip \noindent Then the least fixed point of the operator $C_{\sig,\dl,b}$
  equals $C_{\sig,\dl,b,|2^{D \times \mathbb{N}}|}$.
\end{lemma}

\begin{proof}
  We'll start with the case that $\Var$ is finite.
  
  $T = \Valuation_{\Var,D}$ is a set with a chain-complete partial order $\leq$
  (the standard ordering, lemma \ref{valChainComplete}) such that all well-founded
  chains of $T$ have a cardinality at most $D \times \mathbb{N}$
  (lemma \ref{wellOrderedChainsSmall}), and $C_{\sig,\dl,b}$ is a monotonic
  operator on $T$.
  
  The iterative construction $C_{\sig,\dl,b,n}$ agrees with the one prescribed by
  lemma \ref{coConst} (lemmas \ref{leastTrisets}, \ref{leastUpperBoundsValuations}).
  By that lemma,
  \[\lfp(C_{\sig,\dl,b}) = C_{\sig,\dl,b,|2^{D \times \mathbb{N}}|}\,.\]
  
  It remains to prove the same when $\Var$ is infinite.
  
  By definition, any infinite definition list $\dl$ is a union of finite definition
  lists $\var{fdl}$. The iterative construction of $\dl$ is the "union"\footnotemark
  of the iterative constructions of elements of $\var{fdl}$. Therefore,
  the least ordinal at which $\dl$'s fixpoint appears in $\dl$'s iterative
  construction equals the supremum of the least such ordinals of elements
  of $\var{fdl}$. All such ordinals are at most $|2^{D+\mathbb{N}}|$.
  
  \footnotetext{Technically, it is the union of unions of the valuations of the
  corresponding iterative constructions at the respective ordinal stages.
  This is because if new definitions are added to a definition list, they
  do not interfere with the semantics of the already existing ones.}
\end{proof}

Now we can show that the operator $B$ is monotonic with respect to the approximation
ordering, and that its corresponding iterative construction produces $B$'s least
fixed point.

\begin{lemma}[Monotonicity of $B$] \hfill \\
  The operator $B_{\sig,\dl}$ is monotonic with respect to the approximation ordering.
\end{lemma}

\begin{proof}
  Let $b_0, b_1\colon \Valuation_{\Var,D}$ such that $b_0 \approximates b_1$.
  We'll show that for any $n$,
  \[C_{\sig,\dl,b_0,n} \approximates C_{\sig,\dl,b_1,n}\,,\]
  from which it follows that
  \[\lfp(C_{\sig,\dl,b_0}) \approximates \lfp(C_{\sig,\dl,b_1})\,.\]
  
  Suppose $C_{\sig,\dl,b_0,n} \approximates C_{\sig,\dl,b_1,n}$. Then
  $C_{\sig,\dl,b_0,n+1} \approximates C_{\sig,\dl,b_1,n+1}$ follows from
  the approximation monotonicity of interpretation (lemma \ref{monoInterpKnow}).
  
  Suppose that for any $n$ less than some limit ordinal $l$,
  \[C_{\sig,\dl,b_0,n} \approximates C_{\sig,\dl,b_1,n}\,.\]
  Then, by the definition of the approximation ordering,
  \begin{gather*}
    C_{\sig,\dl,b_0,n}[0] \subseteq C_{\sig,\dl,b_1,n}[0]\,,\\
    C_{\sig,\dl,b_0,n}[1] \supseteq C_{\sig,\dl,b_1,n}[1]\,.
  \end{gather*}
  
  So
  \begin{gather*}
    \bigcup_{n \in l}C_{\sig,\dl,b_0,n}[0] \subseteq
      \bigcup_{n \in l}C_{\sig,\dl,b_1,n}[0]\,,\\
    \bigcup_{n \in l}C_{\sig,\dl,b_0,n}[1] \supseteq
      \bigcup_{n \in l}C_{\sig,\dl,b_1,n}[1]\,.\\
  \end{gather*}
  
  Therefore
  \begin{gather*}
    (\bigcup_{n \in l}C_{\sig,\dl,b_0,n}[0], \bigcup_{n \in l}C_{\sig,\dl,b_0,n}[1])
      \approximates
    (\bigcup_{n \in l}C_{\sig,\dl,b_1,n}[0], \bigcup_{n \in l}C_{\sig,\dl,b_1,n}[1])\\
    C_{\sig,\dl,b_0,l} \approximates C_{\sig,\dl,b_1,l}
  \end{gather*}
\end{proof}

\begin{lemma}[Correctness of construction of $B$'s least fixed point] \hfill \\
  Let
  \begin{compactitem}
    \item $\sig = (D, A, \Op, I)$ be a signature,
    \item $\Var$ a set of variables, and
    \item $\dl$ a $\DefList_{\sig,\Var}$.
  \end{compactitem}
  
  \medskip \noindent Then the least fixed point of the operator $B_{\sig,\dl}$
  equals $B_{\sig,\dl,|2^{D \times \mathbb{N}}|}$.
\end{lemma}

\begin{proof}
  Analogous to that of lemma \ref{coConstOpC}, with the approximation ordering.
\end{proof}

\section{The well-founded model}
Now that we defined the operators (and the iterative constructions),
we can finally define the semantics of WFC.

\begin{defBox}
  Let $\sig = (D, A, \Op, I)$ be a signature, and $\dl$ a $\DefList_{\sig,\Var}$.
  
  \medskip \noindent $M_{\sig,\dl} = \lfp(B_{\sig,\dl}) \setminus A \\
    \phantom{M_{\sig,\dl}} = B_{\sig,\dl,|2^{D \times \mathbb{N}}|} \setminus A$
  \phantom{aa} is the \textit{well-founded model} of $\dl$.
\end{defBox}

The well-founded model $M_{\sig,\dl}$ is a valuation such that $M_{\sig,\dl}(x)$
is the triset represented by the definition $x$ of $\dl$.
A concrete example where we use the approximative values is show in TODO.

TODO: now, there should be a proposition saying the well-founded model is a model,
BUT the approximative values fuck that up. Try to find suitable restrictions
on how value approximation works so that for any signature, the well founded
model is an actual model. Instead, let's have this:

\begin{lemma}[If $A$ is empty, the well-founded model is a model] \hfill \\
  Let $\sig = (D, \{\}, \Op, I)$ be a signature. Then for any definition list $\dl$,
  $M_{\sig,\dl}$ is a model of $\dl$.
\end{lemma}

\section{Conjecture: simpler semantics}
This iterative construction only uses one valuation, which it updates using a standard
interpretation function (ie. eg. complements are really complements), and whose limit
points are defined using limit mix -- an operation analogical to $\limsup$.

It seems to work for trivial examples, however, I'm not sure how I would go about
proving equivalence. (Not that I've given it much thought.)

TODO define limit of sequences of valuations, note that it corresponds with set limit
and limit of functions when trisets are taken as characteristic functions.
A limit of a sequence of valuations contains the value $v$
if from some index all valuations have $v$ as member, does not contain
the value if from some index all valuations don't, else the limit borders $v$.

asdf

$\MBS$ stands for Mix-Based-Semantics.

\begin{defBox}
  Let $\sig$ be a signature. The gist of the idea is this:
  
  \medskip \noindent
  $\begin{aligned}
    & \MBS_{\sig,\dl,0} & &= v_e \\*
    & \MBS_{\sig,\dl,n+1} & &= I_{\sig}(\MBS_{\sig,\dl}) \\*
    & \MBS_{\sig,\dl,l} & &= \limMix_{n \to l} \MBS_{\sig,\dl,n}
  \end{aligned}$
\end{defBox}

However, that is too coarse because of definitions like \texttt{let T = \tde \tde T},
which are (and should be) undetermined. What we need is to define the steps not
per definitions, but per every expression of the definition.

TODO
Open question: is there a natural operator whose iterative construction is MBS?


\chapter{Tracking undeterminedness}



























.

.

Two example special cases of WFC (in addition to WFRQ) are presented in
chapter~\ref{TODO}. These are WFPQ, whose basic operations are cartesian
products and projections, and quantified boolean grammars, whose basic operations
are concatenation and the constant operations representing the empty word and
letters of the alphabet\footnote{Disallowing quantified unions and intersections
in quantified boolean grammars results in ordinary boolean grammars~\cite{TODO}}.


TODO - HERE BE DRAGONS

\chapter{The candidates for sets}
In this chapter, we describe the structures that we see as potential candidates
for the sets of our set theory.

TODO looking for models of an unknown theory is strange.

\section{The deep/rough syntactic model}

TODO if the set of down-classical sets (make all undetermined elements not belong)
of the rough model is larger than the set of classical sets, then the set of down-classical
sets should also be considered a potential model of BST

TODO take into account the regularized version of the deep model (take all the classical
sets that a set is approximating, define membership to be true if true for all combinations,
false if false for all combinations, undetermined otherwise). Is it isomorphic
to the shallow model?

TODO also try using (arbitrary) union and its complement.
Union of A - a set of sets S such that there exists E containing S in A
Dual union of A - a set of sets S such that for all E containing S, E in A

D(A) = ~U(~A)

TODO naturalness check: do the models correspond to ITTM-3-computable sets?

A 3-function is (strictly) computable iff for some model of computation,
there exists a machine that accepts on all members and rejects all nonmenbers
(and else doesn't halt).

Given a reasonable
An ITTM-computable set is an ITTM-computable function from I
functions
computable by an ITTM

does the floor (or, equivalently, ceil) of the rough model correspond to
computable sets of ITTMs with oracle for ordinary ITTMs?

\section{The shallow syntactic model}
A shallow model is built of the classical sets of the deep model.

\section{The positive syntactic model}

\section{The "sets" of WFRQ}
We hope this one is equivalent to the deep syntactic model, if not, we need to
consider it (and its shallow version) as another potential semantics for BST.


\chapter{A general three-valued logic}
TODO make a logic where variables hold values, not collections of them,
then make the Logic of Partial Collections a special case of it?

TODO describe the problems of making the logic too general - eg. if one adds one predicate
per original predicate that is true iff the original predicate is undetermined,
and else false, then undetermined ceases to act like "unknown". So should
such predicates be disallowed (by some monotonicity condition? on what partial order?),
should such structures be allowed, but not (finitely?) axiomatizable, am I wrong about
that the "unknown" interpretation ceases to apply, or should I get used to that it no
longer does in first-order three-valued logic?

\chapter{A three-valued logic/Logic of partial collections}
In this chapter, we describe a logic similar to first-order logic, tentatively named
"Logic of Partial Collections" (LPC), where the "partial" should be understood
as "partially specified".

The logic differs from first-order logic in that variables hold collections
of elements instead of elements themselves. However, like in first-order logic,
quantifiers in LPC range over elements, or rather one-element collections,
instead of over arbitrary collections as in second-order logic.

The collections are three-valued in the sense that every element either belongs
to a collection, doesn't belong to it, or its membership in that collection is
undetermined. Collections with undetermined elements are meant to potentially represent
any two-valued collection that would result from the three-valued one if the
membership of all undetermined elements became settled. The undetermined part
of a three-valued collection represents our lack of information of which collection
precisely we are talking about.

Likewise, the logical connectives of LPC satisfy the following condition:
if the replacement of the undetermined part of an input $i$ with classical
logical values always results in the same output, then that output is the output
corresponding to the input $i$, else the output is undetermined.
This implies "undetermined" acts as "unknown", and getting to know more of the input
may only result in potentially getting to know the previously unknown output,
not a change in the output if it was already known.

As a consequence, the logic is \textit{not} functionally complete. For instance,
a unary logical connective mapping true and false to false and undetermined to true
is inexpressible, because such a connective would break the above condition.
LPC is, however, functionally complete in its classical part.

I followed~\cite{firstOrderLogic} to make sure my formalization of LPC is reasonably close
to first-order logic.

\section{Syntax}
The syntax of our logic depends on the chosen signature that determines which
functions and predicates can be used in its terms and formulas.

\begin{defBox}
  A signature is a triple $(\func, \pred, \arity)$, where
  \begin{compactenum}
    \item $\func$ and $\pred$ are disjoint sets containing the function and predicate
      symbols, respectively, and
    \item $\arity\colon \func \cup \pred \to \mathbb{N}$ determines the arity
      of the symbols.
  \end{compactenum}
  
  %\medskip \noindent $\symb = \func \cup \pred$ is the set of symbols.
\end{defBox}

\subsection{Terms}
\begin{align*}
  E = x~|~\Empty~|~\Universal~|~f(...)~|~E \cup E~|~E \cap E~|~\ct E%
  ~|~\bigcup_{x \in E}E~|~\bigcap_{x \in E}E~|~\conditional{F}{E}{E}
\end{align*}

\noindent Terms represent collections of elements.

\begin{defBox}
  Let $\Var$ be the set of all variables, we assume there are countably many.
\end{defBox}

\noindent Given a signature $(\func, \pred, \arity)$, terms are
recursively defined as follows:

\begin{compactenum}
  \item Variables are terms.
  \item $\Empty$ and $\Universal$, representing the empty and universal collection,
    respectively, are terms.
  \item If $t_0, ..., t_n$ are terms, $f \in \func$ and $\arity(f) = n$,
    then $f(t_0, ..., t_n)$ is a term.
  \item If $t_0$ and $t_1$ are terms, then the binary union $t_0 \cup t_1$ is a term.
  \item If $t_0$ and $t_1$ are terms, then the binary intersection $t_0 \cap t_1$ is a term.
  \item If $t_0$ is a term, then the complement $\sim t_0$ is a term.
  \item If $t_0$ and $t_1$ are terms, then the quantified union
    $\displaystyle \bigcup_{x \in t_0} t_1$ is a term.
  \item If $t_0$ and $t_1$ are terms, then the quantified intersection
    $\displaystyle \bigcap_{x \in t_0} t_1$ is a term.
  \item If $f_0$ is a formula (see below), and $t_0$ and $t_1$ are terms,
    then the conditional $\conditional{f_0}{t_0}{t_1}$ is a term.
\end{compactenum}

\begin{defBox}
  $\Term_V$, where $V$ is a set of variables, is the set of all
  terms whose free variables are in $V$.\footnote{A formal definition of
  $\Term_V$ in ZFC is given in appendix~\ref{appendix:ZFC}.}
  
  \medskip \noindent $\Term = \Term_{\Var}$ is the set of all terms.
\end{defBox}

\subsection{Definitions}

TODO replace "name" by variable everywhere?

Named terms are called definitions. The following definitions are implicitly part
of all definition lists (see below) where they are mentioned (unless being defined
otherwise).

\begin{defBox}
  \texttt{%
    let Empty = Empty; \\*
    let Universal = \tde Empty; \\*
    let Undetermined = \tde Undetermined;
  }
\end{defBox}

\subsection{Definition lists}

TODO statements should be monotonic under the approximation ordering

Definitions are grouped into definition lists. A definition list allows its
definition to refer to each other.

\begin{defBox}
  A family of terms is a function $f\colon V \to \Term_V$ for some $V \subseteq \Var$.
  
  \medskip \noindent A family of terms is a \textit{definition list} iff it is the union
  of (possibly infinitely many) finite families of terms.
  
  \medskip \noindent $\DList_V$ is the set of definition lists whose domain is $V$.
  
  \noindent $\DList = \DList_Var$ is the set of all definition lists.
\end{defBox}

The purpose of the restriction that defines definition lists is to disallow those
definition lists that would contain infinite dependency chains between definitions,
like: \texttt{let T0 = T1; let T1 = T2; let T = T3; ...}

\subsection{Formulas}
\begin{align*}
  F = ~\false~|~\true~|~E = E~|~P(...)~|~F \lor F~|~F \land F~|~\neg F%
  ~|~\exists x \in T\colon F~|~\forall x\in T\colon F
\end{align*}

\noindent Formulas represents mathematical statements, and have a truth value.
Given a signature $(\func, \pred, \arity)$, formulas are recursively defined as follows:
\begin{compactenum}
  \item $\true$ and $\false$, representing true and false, respectively, are formulas.
  \item If $t_0$ and $t_1$ are terms, then $t_0 = t_1$ is a formula.
  \item If $t_0, ..., t_n$ are terms, $P \in \pred$ and $\arity(P) = n$,
    then $P(t_0, ..., t_n)$ is a formula.
  \item If $f_0$ and $f_1$ are formulas, then the disjunction $f_0 \lor f_1$ is a formula.
  \item If $f_0$ and $f_1$ are formulas, then the conjunction $f_0 \land f_1$ is a formula.
  \item If $f_0$ is a formula, then the negation $\neg f_0$ is a formula.
  \item If $t_0$ is a term and $f_0$ is a formula, then $\exists x \in t_0\colon f_0$
    is a formula.
  \item If $t_0$ is a term and $f_0$ is a formula, then $\forall x \in t_0\colon f_0$
    is a formula.
\end{compactenum}

\noindent We may use $F \implies F$ as syntax sugar for $\neg F \lor F$.

\section{Semantics}
In the whole section, we will assume a given signature $s = (\func, \pred, \arity)$.

\subsection{Relations}

An $n$-ary relation on $D$ is a three-valued collection of $n$-tuples
of two-valued collections of elements of $D$.

TODO perhaps a relation should be a three-valued collection of two-valued relations?


\begin{defBox}
  Let $D$ be an arbitrary set, which we'll call the domain, and $n$ a finite ordinal.
  
  \medskip \noindent An $n$-tuple of elements of some set $S$ is a function from $n$ to $S$.
  
  \medskip \noindent An $n$-ary relation on $D$ is a pair $(L, U)$,
  where $L$ and $U$ are sets of $n$-tuples of subsets of $D$ and $L \subseteq U$.
\end{defBox}

Functions are a special case of relations.

\begin{defBox}
  A relation $(L, U)$ is classical, or two-valued, iff $L = U$.
  
  \medskip \noindent A functional $n$-ary relation is a classical $n$-ary relation
  such that $0 < n$ and for all tuples $t_a = (t_{a,0}, ..., t_{a,n})$ and
  $t_b = (t_{b,0}, ..., t_{b,n})$ of that relation,
  $(t_{a,1}, ..., t_{a,n}) = (t_{b,1}, ..., t_{b,n})$ implies $t_a = t_b$.
\end{defBox}

\begin{questionBox}
  \begin{question}
    Could I loosen the definition of functional relation so that functions
    with several undetermined return values are allowed?
  \end{question}
  
  \medskip \begin{question}
    Should all functions be required to be monotonic?
  \end{question}
\end{questionBox}

TODO delete the rest of the subsection?:
We defined a relation such that it naturally contains, doesn't contain, or borders
tuples of two-valued collections. We will now extend the membership relation
of relations to tuples of three-valued collections, using the notion of an extended
relation -- a three-valued collection of tuples of three-valued collections.

\begin{defBox}
  A three-valued collection $(L, U)$ approximates a two-valued collection $C$
  iff $L \subseteq C \subseteq U$.
  
  \medskip \noindent An $n$-ary expanded relation on $D$ is a pair $(L, U)$,
  where $L$ and $U$ are sets $n$-tuples of pairs $(l, u)$, $L \subseteq U$,
  and $l \subseteq u \subseteq D$.
  
  \medskip \noindent A relation $r$ induces an extended relation $r_e = (L, U)$ iff:
  \begin{compactenum}
    \item 
  \end{compactenum}
\end{defBox}

lemma: the membership status of a tuple $t$ of three-valued collections in a relation
equals the mix of the membership statuses of all the tuples of two-valued collections
that $t$ approximates. TODO or perhaps just define the interpretation of formulas
using mix, and delete "extended relations"?

\subsection{Structures}
A structure is an object relative to which one judges the truth of formulas,
and which determines how to interpret terms and definitions.

\begin{defBox}
  A structure is a pair $(D, v)$ where
  \begin{compactenum}
    \item $D$ is called the domain of the structure, and
    \item $v$ is called valuation, and is a function from symbols to relations such that:
      \begin{compactenum}
        \item for every $f \in \func$, $v(f)$ is an $(\arity(f) + 1)$-ary
          functional relation,
        \item for every $P \in \pred$, $v(P)$ is an $(\arity(P))$-ary relation.
      \end{compactenum}
  \end{compactenum}
\end{defBox}

TODO structures are descriptively equivalent of they satisfy the same theories

\subsection{Interpretation}
The interpretation of terms and formulas is defined recursively on their structure.

\begin{defBox}
  TODO
\end{defBox}

TODO the mix is the greatest lower bound with respect to the approximation ordering.

TODO two kinds of semantics - arbitrary collections vs definable collections

perhaps call them:
freewheeling semantics (does not bother to define what a collection is) vs
grounded (?, or perhaps "restricted") semantics (the collections are the definable
collections)

TODO if functions are only arbitrarily defined on classical collections, and the
definition on nonclassical collections N is extended by sth like "for all
classical collections that N could represent, return the union of that",
should the union be $\cup_{...} X$ or $\cup_{...} \{ X \}$?

TODO possible restriction - only allow relations/functions that are defined pointwise,
ie that are definable on the elements, not collections of them.

\begin{defBox}
  $\TVal = \{ 0, \bot, 1 \}$ is the set of truth values.
\end{defBox}

\section{Deductive system}


\chapter{Formulas as syntactic sugar}
TODO can formulas be algorithmically converted to definitions that are inhabited
iff those formulas are true?


\chapter{Definitions as syntactic sugar}
TODO is this possible?


\chapter{Boolean set theory}
In this chapter, we define the syntax of BST, and informally describe its meaning.
The syntax may be denoted using two possible notations -- math (eg. $A \cup B$)
or code notation (eg. \texttt{A | B}). We'll use both interchangeably in this document.

conjecture: for each theory/structure that has predicates that are undetermined
on some unit element, there is another equivalent structure where all predicates
are classical on all unit arguments (an element E is a unit element if for all
elements A, B such that A|B=E, E = A or E = B)

\section{Terms and formulas of BST}
Expressions are recursively defined as follows:

\begin{align*}
  E = x~|~\Empty~|~\Universal~|~\pSet(E)~|~\mSet(E)~|~E \cup E~|~E \cap E~|~\ct E%
  ~|~\bigcup_{x \in E}E~|~\bigcap_{x \in E}E~|~\conditional{F}{E}{E}
\end{align*}

\begin{align*}
  F = ~\false~|~\true~|~E \in E~|~~E = E~|~F \lor F~|~F \land F~|~\neg F%
  ~|~\exists x \in E\colon F~|~\forall x\in E\colon F
\end{align*}

\noindent We'll use the letter $e$ with an optional subscript (eg. $e_0$) in math
notation and square brackets (eg. \texttt{[e0]}) in code notation as metavariables
that hold expressions. In detail, the expressions are:

\begin{description}
  \item[Names] \hfill \\
    Refer to other sets. Our names begin with a letter, which is
    followed by letters and numbers.\footnote{Using regex notation, our names
    are those strings that match
    [a\nobreakdash-zA\nobreakdash-Z][a\nobreakdash-zA\nobreakdash-Z0\nobreakdash-9]*.}
    
  \item[The empty set] \hfill \\
    Represents the set containing no elements.
    
  \item[The universal set] \hfill \\
    Represents the set containing all sets.
    
  \item[Power set] \hfill \\
    $\pSet(e)$ or \texttt{P([e])} represents the set of all subsets of the set
    represented by the expression $e$.
    
  \item[Meet set] \hfill \\
    $\mSet(e)$ or \texttt{M([e])} represents the set of all sets having a common
    element with the set represented by the expression $e$.
    
  \item[Binary union] \hfill \\
    $e_0 \cup e_1$ or \texttt{[e0] | [e1]} represents the set of those sets that
    are elements of either $e_0$ or $e_1$.
    
  \item[Binary intersection] \hfill \\
    $e_0 \cap e_1$ or \texttt{[e0] \& [e1]} represents the set of those sets that
    are elements of both $e_0$ and $e_1$.
    
  \item[Complement] \hfill \\
    $\ct e$ or \texttt{\tde [e]} represents the set of those sets that
    are \textit{not} elements of $e$.
    
  \item[Quantified union] \hfill \\
    \[\bigcup_{x \in e_0}e_1\quad\quad\quad\texttt{Un x: [e0] => [e1]}
    \quad\quad\quad\texttt{Un x: [e0] \{ [e1] \}}\]
    Represents the union of all instances of its body $e_1$ where the name
    $x$ is replaced by the members of $e_0$.
  \item[Quantified intersection] \hfill \\
    \[\bigcap_{x \in e_0}e_1\quad\quad\quad\texttt{Ir x: [e0] => [e1]}
    \quad\quad\quad\texttt{Ir x: [e0] \{ [e1] \}}\]
    Represents the intersection of all instances of its body $e_1$ where the name
    $x$ is replaced by the members of $e_0$.
    
  \item[Conditional operator] \hfill \\
    $\conditional{f_0}{e_0}{e_1}$ or \texttt{[f0] ? [e0] : [e1]} represents a set
    that equals $e_0$ if the formula (defined below) $f_0$ is true, and equals
    $e_1$ if $f_1$ is false.
    
    This operator is included for convenience, but as we'll see, it can be considered
    just syntax sugar. To prove it, though, we'll define it as an ordinary expression.
\end{description}

[While theories usually are specified by axioms, we are going to .. from the back/
go the opposite direction: we'll start with our desired models, and then see
if we can find reasonable axioms whose models/theories are close enough.]

There is a question of whether the undeterminedness should be shallow or not,
in the sense of whether $\{ \{ A? \} \}$ and $\{ \{\}?, \{ A \}? \}$ should be
the same set or not. Answering yes leads to shallow semantics (TODO which I'm not
sure can be defined), answering no leads to deep semantics (which are surely possible,
but I believe less desirable, because in such semantics, quantifying over all sets
necessarily quantifies over the non-classical ones, so there's no way to avoid it).

The models presented below are called syntactic models because they use the syntax
of BST to define its semantics\footnote{In other words, they can be considered
"syntax in disguise".}. This makes them countable; however, this does not imply
there aren't (more) natural models of higher cardinalities.

Because the syntactic models are
interpret a set S as a collection of formulas that define sets that are elements of S.

\section{Deep syntactic model}

\subsection{Valuations}
Valuations let us interpret expressions by giving meaning to names.

\begin{defBox}
  $\DSet = P(\Name) \times P(\Name))$
  
  \medskip \noindent
  A valuation is a function $v\colon \Name \to \DSet$.
\end{defBox}

\subsection{Interpretation}

\begin{defBox}
  $I_{b\colon \Name \to \DSet}\colon (c\colon \Name \to \DSet) \to \Term \to \DSet$
  
  \medskip \noindent $I_b(c)(x) = c(x)$
  
  \medskip \noindent $I_b(c)(\Empty) = (\emptyset, \emptyset)$
  
  \noindent $I_b(c)(\Universal) = (\Name, \Name)$
  
  \noindent $I_b(c)(\pSet(e)) = \displaystyle\bigcup_{x \in \Name}\begin{cases}
    x & b(x) \subseteq c(e) \\
    \emptyset & \text{ else.}
  \end{cases}$
  
  \medskip \noindent $I_b(c)(\mSet(e)) = \displaystyle\bigcup_{x \in \Name}\begin{cases}
    x & c(x) \meet c(e) \\
    \emptyset & \text{ else.}
  \end{cases}$
  
  \medskip \noindent $I_b(c)(e_0 \cup e_1) = I_v(e_0) \cup I_v(e_1)$
  
  \noindent $I_v(e_0 \cap e_1) = I_v(e_0) \cap I_v(e_1)$
  
  \noindent $I_v(\ct x) = \Name \setminus~v(x)$
  
  \medskip \noindent $\displaystyle I_v(\bigcup_{x \in \Universal}e) =
    \bigcup_{x \in \Name}I_{v[x \mapsto v(x)]}(e)$
  
  \medskip \noindent $\displaystyle I_v(\bigcap_{x \in \Universal}e) =
    \bigcap_{x \in \Name}I_{v[x \mapsto v(x)]}(e)$
  
\end{defBox}

\begin{defBox}
  
\end{defBox}

\section{Shallow syntactic model}
An attempt to define them:

There are multiple possible approaches to defining the domain of sBST, and I don't
know if any one works.
\begin{compactenum}
  \item Take the classical sets of dBST as the domain
  \item Generate it using positive definitions
\end{compactenum}
Ideally, these would result in the same domain, but what do I know.

\subsection{Positive expressions}

\begin{defBox}
  We'll define an expression $e$ as positive iff
  \begin{compactenum}
    \item it does not contain the conditional operator,
    \item for all its subexpressions \texttt{Un/Ir x: [e0] => [e1]},
      $e_0 = \Universal$, and
    \item for all its subexpressions $\ct e$, $e$ is a bound name.
  \end{compactenum}
  
  \medskip \noindent $\PExpr$ is the set of all positive expressions.
\end{defBox}

\subsection{Two-valuations}
A two-valuation lets us interpret names as sets of names.
This would make sense if I bothered to explain it. TODO.

\begin{defBox}
  A two-valuation is a function $v\colon \Name \to P(\Name)$.
\end{defBox}

\subsection{Two-interpretation}
A two-interpretation is an extension of two-valuations to all positive expressions.

\begin{defBox}
  $I_{v\colon \Name \to P(\Name)}\colon \PExpr \to P(\Name)$
  
  \medskip \noindent $I_v(x) = v(x)$
  
  \medskip \noindent $I_v(\Empty) = \emptyset$
  
  \noindent $I_v(\Universal) = \Name$
  
  \noindent $I_v(\pSet(e)) = \displaystyle\bigcup_{x \in \Name}\begin{cases}
    x & v(x) \subseteq v(e) \\
    \emptyset & \text{ else.}
  \end{cases}$
  
  \medskip \noindent $I_v(\mSet(e)) = \displaystyle\bigcup_{x \in \Name}\begin{cases}
    x & v(x) \cap v(e) \text{ is non-empty} \\
    \emptyset & \text{ else.}
  \end{cases}$
  
  \medskip \noindent $I_v(e_0 \cup e_1) = I_v(e_0) \cup I_v(e_1)$
  
  \noindent $I_v(e_0 \cap e_1) = I_v(e_0) \cap I_v(e_1)$
  
  \noindent $I_v(\ct x) = \Name \setminus~v(x)$
  
  \medskip \noindent $\displaystyle I_v(\bigcup_{x \in \Universal}e) =
    \bigcup_{x \in \Name}I_{v[x \mapsto v(x)]}(e)$
  
  \medskip \noindent $\displaystyle I_v(\bigcap_{x \in \Universal}e) =
    \bigcap_{x \in \Name}I_{v[x \mapsto v(x)]}(e)$
  
\end{defBox}

TODO shit, powerset is not monotonic wrt the standard ordering.
We need a better ordering. Or another approach.


\chapter{Comparing deep and shallow BST}

\begin{questionBox}
  \begin{question}
    Are the classical deep sets the same as the classical shallow sets?
  \end{question}
  
  \medskip \begin{question}
    Is there a set of sets classical in either semantics, in either semantics?
  \end{question}
  
  \medskip \begin{question}
    What about mutual expressibility?
  \end{question}
\end{questionBox}


\chapter{Deductive system}
TODO move this into other chapters

\section{Rules of inference}

\section{Axioms of BST}
Some candidates:

$\forall x\colon x \notin \Empty$

$\forall x\colon x \in \Universal$

$\forall x,y\colon (x \in \pSet(y) \iff \forall z\colon z \in x \implies z \in y)$

$\forall x,y\colon (x \in \mSet(y) \iff \exists z\colon z \in x \land z \in y)$

$\forall x,y,z\colon (z \in x \cup y \iff z \in x \lor z \in y$

$\forall x,y,z\colon (z \in x \cap y \iff z \in x \land z \in y$


\chapter{Algorithms, type checking, etc?}

TODO does this belong here?

 When you prove something once, it should be proven
everywhere. Yes, this leads to non-locality of type checking, because, where a proof
in one part of the code affects the correctness of code everywhere else.

A proof in [my] programming language should ideally be readable even to someone that has
never seen the language before.\footnote{Assuming the particular proof in BST and ZFC
would look essentially the same.}


\printbibliography[heading=bibintoc,resetnumbers=0]

\appendix

\chapter{Proof of correctness of iterative constructions}\label{proofCoConst}

We'll start with a lemma limiting the cardinality of well-ordered chains
of finite-domain valuations.

The lemma is not strictly necessary if one is willing to accept $|2^{2^D|}$
as the ordinal up to which we need to build our iterative constructions,
instead of just $|2^D|$. The larger limit follows by a simple application
of the pigeonhole principle.%
\footnote{I feel limiting the cardinality of the iterative construction
has certain benefits, although I am unaware of any.}

\wellOrderedChainsSmall*

\begin{proof}
  TODO asdf "characteristic function"
  
  For the purposes of this proof, we'll use the definition 1 of trisets, that is,
  a triset is a function from $D$ to $\{0,\bot,1\}$. Note the standard
  ordering is the pointwise order for $0 < \bot < 1$, and the approximation
  ordering is the pointwise order for $\bot < 0,1$.
  
  Let $V'$ be $V$ without its greatest element, if it exists. For any $v \in V'$,
  $v$ has a successor in $V$ -- the least element greater than $v$.
  
  Let $f\colon V' \to \Var \times D \times \{0,\bot,1\}$ be a function
  that to $v$ assigns a triple $(x, d, t)$ such that the truth value $t$
  of membership of $d$ in $v(x)$ increases at $v$'s successor. (More formally,
  that to $v_0$ assigns a triple $(x, d, v_0(x)(d))$ where $v_1$ is $v_0$'s
  successor and $v_0(x)(d) < v_1(x)(d)$.)
  
  The function $f$ is an injection. (In a chain, no element can "increase" its
  membership twice to the same value.) Imagine $f(v_0) = (x, d, a)$ and
  $f(v_1) = (x, d, b)$, with $v_0 < v_1$. Then $a < v_1(x)(d) = b$, so $a \neq b$.)
  
  We have an injection from $V'$ to $\Var \times D \times \{0,\bot,1\}$.
  The latter has the cardinality of $D$ (up to a finite difference),
  so $V'$ and $V$ must as well.
\end{proof}

\pagebreak

\lemmaCoConst*

\begin{proof}
  We'll do the proof in two steps. Zeroth, we'll prove that for any ordinal $n$,
  $O_n$ is (non-strictly) less than any fixed point of $O$, using transfinite
  induction. First, we'll prove that $O_{2^k}$ is a fixed point of $O$. Together,
  these two facts imply that $O_{2^k}$ is the least fixed point of $O$.
  
  \begin{subproof}[Subproof 0]
    $O_0$ is less than any element of $T$, including any fixpoint $t$ of $O$. (Any
    chain-complete ordering has a least element.)
    
    Suppose $O_n$ is less than $t$. Then by the monotonicity of $O$,
    \[O_{n+1} = O(O_n) \leq O(t) = t\,.\]
    
    Suppose that for every $n$ less than some limit ordinal $l$, $O_n$ is less than
    a fixpoint $t$. $t$ is thus an upper bound of $O_{n<l}$. But $O_l$ is the least
    uppper bound, so it must be less than $t$.
  \end{subproof}
  
  \begin{subproof}[Subproof 1]
    Elements $O_n$ for some $n$ form a chain (by the monotonicity of $O$).
    The chain is well-founded, so its cardinality is at most $k$.
    
    There are $2^k$ many ordinals less than $2^k$, so by the pidgeonhole
    principle, there must be distinct $n$ and $m$ such that $O_n = O_m$; let $n$
    be the lesser one. Every element between $O_n$ and $O_m$ equals $O_n$,
    including $O_{n+1} = O(O_n)$. $O_n$ is thus a fixpoint of $O$, and for all
    $k \geq n$, $O_k$ equals $O_n$. In particular, $O_{2^k}$ does, so
    it is a fixpoint of $O$.
  \end{subproof}
\end{proof}


\chapter{TODO notes}

TODO another candidate for a model of BST: WFC of natural numbers with addition
and multiplication.

TODO I should revisit the idea of defining the semantics using
dual definitions:
let A  = B  | A ;
let A' = B' \& A';

let A  = A ;
let A' = A';

Note if this works, then it's unnecessary, because just using
positive formulas defines all the collections definable with complement
as well.

TODO how to define functions?
through least fixpoints wrt partial descriptions, optimal fixed points,
greatest fixed points?

should this contain only finite sets of natural numbers? I guess so
let SetNat = {{}} | Ex n: Nat .. { SetNat | { n } }

similarly, should this be the empty set? I guess not.
let F = Any -> F;

Here the problem is self-reference. Greatest-fixpoint semantics when it comes
to self-reference are ok, general greatest-fixpoint semantics are not.
A set should be isomorphic to a function Any -> 2. Getting better approximations
depth-wise would populate F, but SetNat has constant depth. And breadth-wise,
there should be no greatest-fixpoint-like semantics.

Also, `let R = P(R)` should include the set s = {s}.

let Nat = {{}} | Ex n: Nat .. n | { n }

x in Ex x: X .. B <=> x in B[x in X]

// The set S of all sets whose elements are all in S.
// Should this set include the set $A = {A}$?
let S = Ex s .. All e: s .. Ex c: { e } \& S .. s;

let A = { A };

I found an answer to my question why record sets are best defined
using least fixed points, but function sets with greatest fixed points.
The reason is that records are well-founded, while functions are not
(A = { (null, A) }) is a function, accepting null and returning itself.
Least fixed points do not work well for non-well-founded data structures.

TODO can I mix least and greatest fixpoint definitions? Is it stricty more
expressive as either?

could a set be formalized as `f: N* -> P(N) | null` such that
f([]) != null,
f(s) != null \& e in f(s) <=> f([ ...s, e ])!

\section{Category theoretic stuff}
Smart people I admire use category theory. Worse, they use it for [stuff]
related to topics I try to explore in this document. I am not so smart as to
think in it. (The constructions I have used so far have been very uncategorical.)
However, because category theory's seeming relatedness/applicability, and out
of fear of my constructions as they are could be less than natural, we'll do
something with initial algebras and final coalgebras, to see if there's any
connection to my constructions, and whether this excersice can give us new insights.

TODO something with initial algebras and final coalgebras.

TODO learn fucking category theory, or delete this section.

\section{The rest}

\begin{defBox}
  Let $\Variable = \mathbb{N}$ be the set of all names.
\end{defBox}

TODO: The set containing exactly the set $a$ (ie, the set $\{ a \}$) can be defined
like this: \\ \texttt{%
  Ex seSuA: P(P(a)) => \\ \phantom{a}
  Ex \_: (All suA: seSuA => All \_: a \& \tde suA => None) \\ \phantom{aaa}
  \& (Ex \_: seSuA => Universal) => seSuA}.

TODO this:
https://arxiv.org/pdf/2112.04436.pdf
and references therein seem to be unrelated, they use three-valued logic
to study partial functions, and I believe my use case is different.
I have only looked at it very briefly, so I might be wrong.

TODO does my set theory contain all the sets of ZF(C)? what extra axioms
are necessary for that, if possible at all? More generally, what is the
relationship between the sets of BST and ZFC

TODO does aczel's anti-foundation "axiom" hold in BST? Is BST anti-well-founded?

TODO is BST effectively axiomatizable?

TODO Soft question: are there things that are only provable using three-valued
objects? Are there things that can be proven fully classically, but where
the three-valued proof is considerably shorter/ more elegant / more desirable
in any sense?

TODO Are WFCs with non-well founded values just conservative extensions of WFCs without them? (Can I simulate the former using the latter?)

TODO this might be relevant, read it:
https://www.cambridge.org/core/journals/journal-of-symbolic-logic/article/abs/self-reference-with-negative-types/5621B22269886CAB0048F97C5DB244EA

TODO because of well-known cardinality issues, we're gonna have to cheat a little.

TODO in general, is it possible to have a set of all non-approximated values?
TODO in general, is it possible to have a set of all well-founded values?
TODO in practical programming, would one get spurious (unintended) non-well-founded
values in their sets either often enough that it would be irritationg, or
could it happen that one could not easily tell just by looking at a definition whether
it induces non-well-founded values, or that once could not tell how to easily or
elegantly get rid of them? In general, would the non-well-founded values be
a pain in the ass, at least sometimes?

TODO some questions, like "Does complement increase the expressive power of
WFC" have an easy answer because of degenerate WFCs, like ones where some values
are "hidden", ie. no custom operations return them under any circumstances.
Is there a reasonably general condition that disallows such degenerate cases?
General both in the sense that it's unrestrictive, as well as that it is useful
for more than one purpose.

TODO call hereditarily countable bisets hecoses?

TODO a condition that avoids pathological WFC signatures?
"There are only finitely many operations, and for every value of $D$,
the triset containing exactly that value is definable."

TODO another candidate: self-containing pairs, where sets are infinite
sequences (val0, (val1, (...))) representing \{ val0, val1, ... \}
another candidate: infinite sequences, as above

TODO extensionality should hold, also the truth of partially undetermined
formulas should be determined by the mix of their classical completions

TODO on one hand, these sets have different classical completions.
A = { {}?, { A }? }: {}, {{}}, {{A}}, {{},{A}}
B = { { A? } }     : {{}}, {{A}}
on the other hand, they only possibly contain the classical sets {} and {A},
so I guess that an argument can be made that by extensionality, they should
be the same set, right? Because they have the same characteristic function.
.
But if they are equal, it would mean that X \& !{{}} and Y \& !{{}} would also
have the same characteristic function -- in effect, you could never remove
.
it seems two incompatible views are emerging:
0. trisets as sets of their classical completions, or
1. trisets as characteristic functions
.
it seems that the view 1 is the one compatible with WFC. I mean, WFC
is based on three-valued characteristic functions

TODO conjecture: this is a useful sanity condition: "every triset that appears
in the iterative construction is definable"
.
another conjecture: for any unsanitary (or insane? :D ... pick a better name)
WFC system, there exists a corresponding one that satisfies the condition

TODO add an open question about the supremum of ordinals clockable by particular
natural WFCs (look at the open question 0 in your magister thesis).
.
In general, salvage as many conjectures and open questions from your MAT as reasonable.

TODO Are there certain (natural) type definitions that
cannot be proven to be wholly determined, but whose 2-valuedness
as an assumption leads to interesting consequences?
TODO is the expressive power of WFCs equal to that of ITTMs?

TODO: the issue I have encountered when trying to automatically define
the approximative values given the rest of the signature is this:
.
My idea was to treat sets of $D$ as the approximative values for its elements.
For instance, $* = P(D)$, $(*, 3) = { (x, 3) \mid x \in D }$, etc. However,
given a triset (containing such approximative values), I don't know how
to define which elements of $D$ are actually approximated (and I'm afraid
this approach is just fundamentally flawed).
.
The reasonable step forward is to say that a triset $s$ approximates a value $d$
iff it contains arbitrarily good approximations of $d$. However, take this
triset: \[\{ *, (*, *), (*, (*, *)), (*, (*, (*, *))), (*, (*, (*, (*, *)))) \}\,.\]
.
The issue is that the approximations do get arbitrarily better, but only in
some directions. What we need is for them to get arbitrarily better in all
directions in order for them to actually approximate a value. However, it
seems to me that in order to define what it means to "get better in all
directions", one needs a notion of "depth" of an approximative value, and I'm
afraid that this notion of depth is not definable -- the information
is simply not in the set, for how would you distinguish between $*$ and
$() | (*, *)$, when in the world of pairs, they are the same set?
.
Does it even make sense to talk about "productive" definitions without
an additional structure on $D$?

TODO mention that distinct sets of classical trisets can have the same characteristic
function (and therefore are represented by the same triset)
.
"Maybe there is an approach to a three-valued set theory that is based on classical
completions, however such an approach seems to be at odds with how WFCs work.
WFCs"

TODO replace all $x[0]$ and $x[1]$ with $\lfoor x \rfloor$ and $\lceil x \rceil$, respectively.

TODO add chapter about two-valued collections, without complement, but with value
approximation

TODO is there a nice (not sure what that meas, but I guess it includes "non-syntactic")
characterization of positive/classical/definable (tri)sets? Or at least a nice generalization.
Something like what Scott-continuity is for computability?

Is every floor of a definable type definable?

TODO this might be of relevance to you:
A Completeness Proof for A Regular Predicate Logic with Undefined Truth Value - Antti Valmari
https://arxiv.org/pdf/2112.04436.pdf
.
perhaps also:
A simple logic for reasoning about incomplete knowledge - Mohua Banerjee, Didier Dubois
https://www.sciencedirect.com/science/article/pii/S0888613X13002478?ref=pdf_download&fr=RR-2&rr=720bf7b3ec9bb36c

TODO given a definition in PC/WFC in productive/greatest fixpoint semantics,
can it be mechanically transformed into an equivalent one in least fixpoint semantics?

TODO so we have quite a lot of semantics: least, productive, greatest, and uncommitted
fixed point semantics, for PC and for WFC. How do they relate in terms of expressive power?
.
For PC: every greatest point can be defined as the least fixed point of the negated
definition, and vice versa.
.
a definition list has only one model iff its uncommitted fixed point is classical

TODO Open question: for any positive-definable set, is the complement positive-definable?
TODO Open question: for any WFC-definable triset, is the complement WFC-definable?

TODO (when) is there a positive "triset of all positive trisets"*?
TODO (when) is there a "triset of all positive trisets"*?
TODO (when) is there a "triset of all trisets"*?
*in the appropriate sense.

TODO given a (ascending/descending) chain of trisets/valuations, their limit equals
their least upper bound/greatest lower bound

TODO is there a classical definable triset that is not positive-definable?

\end{document}
